# CH10 그래프이론
## 복습
1. 크루스칼 알고리즘
  - 그리디 알고리즘
2. 위상 정렬 알고리즘
  - 큐/스택
----
3. 그래프
  - 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조
  - `서로 다른 개체(객체)가 연결되어 있다`는 말을 들으면 그래프 알고리즘을 떠올려야 함
    - ex) 여러 개의 도시가 연결되어 있다
  - **트리 자료 구조**
    - 다익스트라 최단 경로 알고리즘 : 우선 순위 큐 사용 -> 최소힙/최대힙
    - 컴퓨터공학 분야에서는 보통 방향 그래프로 간주  
    
      |설명|그래프|트리|
      |---|---|---|
      |방향성|방향 그래프 혹은 무방향 그래프|방향그래프|
      |순환성|순환 및 비순환|비순환|
      |루트 노드 존재 여부|루트 노드 없음|루트노드 있음|
      |노드간 관계성|부모와 자식 관계 없음|부모와 자식 관계|
      |모델의 종류|네트워크 모델|계층 모델|
    - 구현 방법
      - 인접행렬 : 2차원 배열 사용
        - 메모리 공간 : O(V^2)
        - 시간 : O(1)
        - 플로이드 워셜 알고리즘 -> 노드 개수가 적은 경우
      - 인접 리스트 : 리스트 사용
        - 메모리 공간 : O(E)
        - 시간 : O(V)
        - 다익스트라 최단 경로 알고리즘 -> 노드와 간선 개수가 많은 경우
## 서로소 집합
> - 공통 원소가 없는 두 집합
> - 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조

### union 연산
- 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
### find 연산
- 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

### 서로소 집합 알고리즘
1. 트리 사용
  - 알고리즘  
  ```
  1) union 연산 확인, 서로 연결된 두 노드 A,B 확인해서 부모노드 설정
  2) 모든 union 연산 처리할 때까지 1 반복
  ```
2. 경로 압축
  - find 함수 최적화, 시간 복잡도 개선
  - find 함수를 **재귀적으로 호출**한 뒤, 부모 테이블값을 갱신
  
 ```python
 def find_parent(parent, x):
 if parent[x]!=x:
  parent[x]=find_parent(parent, parent[x])
 return parent[x]
 ```
### 응용
1. 사이클 판별
  - **무방향 그래프** 내에서 사이클 판별할 때 사용
    - cf) 방향 그래프에서 사이클 여부는 DFS를 이용하여 판별
  - 두 노드가 포함되어 있는 집합을 합치는 과정을 반복
    - 루트노드가 서로 다르다면 두 노드에 대하여 union 연산
    - 루트노드가 서로 같다면 사이클 발생
## 신장 트리
> 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프

### 크루스칼 알고리즘
> 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘 중 가장 대표적인 하나

1. 그리디 알고리즘
  - 모든 간선에 대해 정렬 수행
  - 가장 거리가 짧은 간선부터 집합에 포함
  - 단, 이때 사이클을 발생시킬 수 있는 간선의 경우 집합에 포함시키지 않음
2. 특징
  - 트리 자료구조
  - 간선의 개수 = 노드의 개수 - 1
3. 시간복잡도

O(ElogE) (E=간선의 개수)
## 위상 정렬
> 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
> = 선수과목 고려한 학습 순서 설정

1. 알고리즘
```
1) 진입차수가 0인 노드를 큐에 넣는다
2) 큐가 빌 때까지 다음 과정 반복
  - 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
  - 새롭게 진입차수가 0이 된 노드르 큐에 삽입
```
2. 시간 복잡도
O(V+E)
